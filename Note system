# -----------------------------------------------
# NOTE SYSTEM (Reader-style: R8 GUI + R9 Files)
# -----------------------------------------------
# - No dataclasses / typing
# - Plain OOP classes with __init__
# - tkinter for GUI (R8)
# - json/csv file IO (R9)
# - Modular: NotesService (data) + NotesPanel (GUI)
# -----------------------------------------------

import json
import csv
import os
from datetime import datetime
from tkinter import *
from tkinter import messagebox, filedialog


# --------------------------
# Simple Note model (R7/R8)
# --------------------------
class Note:
    """A simple Note object using classic __init__ (no dataclasses)."""

    def __init__(self, id, title, body, course, tags=None, pinned=False,
                 day=None, session_start=None, session_duration=None):
        self.id = id                                 # numeric or string id
        self.title = title                           # short title
        self.body = body                             # long body
        self.course = course                         # course name
        self.tags = tags or []                       # list of strings
        self.pinned = pinned                         # bool
        self.day = day                                # NEW: day of week
        self.session_start = session_start            # NEW: "HH:MM"
        self.session_duration = session_duration      # NEW: minutes (string/int)
        self.created_at = datetime.now().isoformat()  # created timestamp
        self.updated_at = datetime.now().isoformat()  # last updated

    def to_dict(self):
        """Convert to dict for JSON export."""
        return {
            "id": self.id,
            "title": self.title,
            "body": self.body,
            "course": self.course,
            "tags": self.tags,
            "pinned": self.pinned,
            "day": self.day,                                # NEW
            "session_start": self.session_start,            # NEW
            "session_duration": self.session_duration,      # NEW
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }


# --------------------------------
# NotesService: data/persistence
# --------------------------------
class NotesService:
    """Handles storage, loading/saving, and note operations."""

    def __init__(self, data_file="notes_data.json"):
        self._data_file = data_file
        self._notes = {}     # id -> Note
        self._next_id = 1    # simple counter for ids
        self._load()

    # ---------- persistence ----------
    def _load(self):
        """Load notes from JSON file if present (R9.3)."""
        if not os.path.exists(self._data_file):
            return
        try:
            with open(self._data_file, "r", encoding="utf-8") as f:
                raw = json.load(f)
        except Exception:
            return

        self._next_id = raw.get("_next_id", 1)
        for row in raw.get("notes", []):
            # rebuild Note manually (reader style)
            note = Note(
                id=row["id"],
                title=row["title"],
                body=row["body"],
                course=row["course"],
                tags=row.get("tags", []),
                pinned=row.get("pinned", False),
                day=row.get("day"),                               # NEW
                session_start=row.get("session_start"),           # NEW
                session_duration=row.get("session_duration"),     # NEW
            )
            note.created_at = row.get("created_at", datetime.now().isoformat())
            note.updated_at = row.get("updated_at", datetime.now().isoformat())
            self._notes[note.id] = note

    def _save(self):
        """Save notes to JSON (R9.3)."""
        data = {
            "_next_id": self._next_id,
            "notes": [n.to_dict() for n in self._notes.values()]
        }
        with open(self._data_file, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    # ---------- CRUD ----------
    def create_note(self, title, body, course, tags_text,
                    day=None, session_start=None, session_duration=None):
        """Create a new note and persist."""
        note_id = self._next_id
        self._next_id += 1
        tags = self._parse_tags(tags_text)
        note = Note(note_id, title, body, course, tags, pinned=False,
                    day=day, session_start=session_start, session_duration=session_duration)
        self._notes[note_id] = note
        self._save()
        return note

    def update_note(self, note_id, title, body, course, tags_text, pinned,
                    day=None, session_start=None, session_duration=None):
        """Update fields of an existing note."""
        note = self._notes.get(note_id)
        if not note:
            return None
        note.title = title
        note.body = body
        note.course = course
        note.tags = self._parse_tags(tags_text)
        note.pinned = bool(pinned)
        note.day = day
        note.session_start = session_start
        note.session_duration = session_duration
        note.updated_at = datetime.now().isoformat()
        self._save()
        return note

    def delete_note(self, note_id):
        """Delete a note."""
        if note_id in self._notes:
            del self._notes[note_id]
            self._save()
            return True
        return False

    # ---------- queries ----------
    def all_notes(self):
        """Return list of notes sorted: pinned first, then by updated_at desc (approx via ISO)."""
        notes = list(self._notes.values())
        # pinned first; (ISO string) updated_at ascending by default; keep as original style
        notes.sort(key=lambda n: (not n.pinned, n.updated_at), reverse=False)
        return notes

    def search(self, keyword="", course="", tag=""):
        """Filter notes by keyword (title/body), course, or a single tag."""
        keyword = keyword.lower().strip()
        course = course.lower().strip()
        tag = tag.lower().strip()

        result = []
        for n in self._notes.values():
            ok = True
            if keyword:
                if keyword not in n.title.lower() and keyword not in n.body.lower():
                    ok = False
            if ok and course:
                if course != (n.course or "").lower():
                    ok = False
            if ok and tag:
                lowered = [t.lower() for t in n.tags]
                if tag not in lowered:
                    ok = False
            if ok:
                result.append(n)

        # keep same order rule as all_notes()
        result.sort(key=lambda n: (not n.pinned, n.updated_at), reverse=False)
        return result

    def toggle_pin(self, note_id):
        """Flip the pinned flag."""
        n = self._notes.get(note_id)
        if not n:
            return None
        n.pinned = not n.pinned
        n.updated_at = datetime.now().isoformat()
        self._save()
        return n

    def list_courses(self):
        """Unique course names from notes."""
        courses = set()
        for n in self._notes.values():
            if n.course:
                courses.add(n.course)
        return sorted(courses)

    # ---------- export ----------
    def export_csv(self, filepath, notes_list):
        """Export given notes to a CSV file (R9.3)."""
        with open(filepath, "w", newline="", encoding="utf-8") as f:
            w = csv.writer(f)
            w.writerow([
                "id", "title", "course", "day", "session_start", "session_duration",
                "tags", "pinned", "created_at", "updated_at", "body"
            ])
            for n in notes_list:
                w.writerow([
                    n.id, n.title, n.course or "",
                    n.day or "", n.session_start or "", n.session_duration or "",
                    ";".join(n.tags),
                    "yes" if n.pinned else "no",
                    n.created_at, n.updated_at,
                    (n.body or "").replace("\n", "\\n")
                ])

    # ---------- helpers ----------
    def _parse_tags(self, tags_text):
        """Turn 'a, b; c' -> ['a','b','c']."""
        if not tags_text:
            return []
        raw = tags_text.replace(";", ",").split(",")
        cleaned = []
        for t in raw:
            s = t.strip()
            if s:
                cleaned.append(s)
        return cleaned


# ----------------------------
# GUI: NotesPanel (R8 style)
# ----------------------------
class NotesPanel:
    """A tkinter UI for managing notes (Look + Binding + Work + Event Loop)."""

    def __init__(self, root, service):
        self.service = service
        self.root = root
        self.root.title("Note System - Capstone (Reader Style)")

        # ========== Left: listbox with notes ==========
        left = Frame(root)
        left.pack(side="left", fill="both", expand=True, padx=8, pady=8)

        Label(left, text="Notes (pinned first):", font="Arial 12 bold").pack(anchor="w")

        self.listbox = Listbox(left, height=20)
        self.listbox.pack(side="left", fill="both", expand=True)
        self.listbox.bind("<<ListboxSelect>>", self._on_select)

        sb = Scrollbar(left, command=self.listbox.yview)
        sb.pack(side="right", fill="y")
        self.listbox.config(yscrollcommand=sb.set)

        # ========== Right: editor/form ==========
        right = Frame(root)
        right.pack(side="right", fill="both", expand=True, padx=8, pady=8)

        # Title
        Label(right, text="Title").grid(row=0, column=0, sticky="w")
        self.title_var = StringVar()
        Entry(right, textvariable=self.title_var, width=40).grid(row=0, column=1, sticky="we")

        # Course
        Label(right, text="Course").grid(row=1, column=0, sticky="w")
        self.course_var = StringVar()
        Entry(right, textvariable=self.course_var, width=40).grid(row=1, column=1, sticky="we")

        # Tags
        Label(right, text="Tags (comma/semicolon)").grid(row=2, column=0, sticky="w")
        self.tags_var = StringVar()
        Entry(right, textvariable=self.tags_var, width=40).grid(row=2, column=1, sticky="we")

        # Day (OptionMenu)
        Label(right, text="Day").grid(row=3, column=0, sticky="w")
        self.day_var = StringVar(value="")
        OptionMenu(right, self.day_var, "", "Monday", "Tuesday", "Wednesday",
                   "Thursday", "Friday", "Saturday", "Sunday").grid(row=3, column=1, sticky="we")

        # Session start + duration
        sess = Frame(right)
        sess.grid(row=4, column=0, columnspan=2, sticky="we")
        Label(sess, text="Start (HH:MM)").pack(side="left")
        self.sstart_var = StringVar()
        Entry(sess, textvariable=self.sstart_var, width=10).pack(side="left", padx=4)
        Label(sess, text="Duration (min)").pack(side="left")
        self.sdur_var = StringVar()
        Entry(sess, textvariable=self.sdur_var, width=10).pack(side="left", padx=4)

        # Pinned
        self.pin_var = IntVar()
        Checkbutton(right, text="Pinned", variable=self.pin_var).grid(row=5, column=1, sticky="w")

        # Body
        Label(right, text="Body").grid(row=6, column=0, sticky="nw")
        self.body_txt = Text(right, width=40, height=12)
        self.body_txt.grid(row=6, column=1, sticky="we")

        # Buttons row
        btns = Frame(right)
        btns.grid(row=7, column=0, columnspan=2, pady=6, sticky="we")

        Button(btns, text="New", command=self._new_note, width=10).pack(side="left", padx=3)
        Button(btns, text="Save", command=self._save_note, width=10).pack(side="left", padx=3)
        Button(btns, text="Delete", command=self._delete_note, width=10).pack(side="left", padx=3)
        Button(btns, text="Pin/Unpin", command=self._pin_toggle, width=10).pack(side="left", padx=3)
        Button(btns, text="Import .txt", command=self._import_txt, width=12).pack(side="left", padx=3)  # NEW
        Button(btns, text="Export CSV", command=self._export_csv, width=12).pack(side="left", padx=3)

        # Search row (keyword/course/tag)
        search = LabelFrame(right, text="Search")
        search.grid(row=8, column=0, columnspan=2, pady=6, sticky="we")

        Label(search, text="Keyword").grid(row=0, column=0, sticky="w")
        self.kw_var = StringVar()
        Entry(search, textvariable=self.kw_var, width=18).grid(row=0, column=1, sticky="w", padx=4)

        Label(search, text="Course").grid(row=0, column=2, sticky="w")
        self.scourse_var = StringVar()
        Entry(search, textvariable=self.scourse_var, width=12).grid(row=0, column=3, sticky="w", padx=4)

        Label(search, text="Tag").grid(row=0, column=4, sticky="w")
        self.stag_var = StringVar()
        Entry(search, textvariable=self.stag_var, width=12).grid(row=0, column=5, sticky="w", padx=4)

        Button(search, text="Search", command=self._do_search, width=10).grid(row=0, column=6, padx=6)
        Button(search, text="Clear", command=self._clear_search, width=10).grid(row=0, column=7, padx=2)

        # status line
        self.status = StringVar()
        self.status.set("Ready.")
        Label(right, textvariable=self.status, anchor="w", relief="sunken").grid(row=9, column=0, columnspan=2, sticky="we", pady=(8, 0))

        # keep current selected note id
        self._current_id = None

        # initial list fill
        self._refresh_list(self.service.all_notes())

    # ----------------- helpers -----------------
    def _read_body(self):
        return self.body_txt.get("1.0", "end-1c")

    def _set_body(self, text):
        self.body_txt.delete("1.0", END)
        self.body_txt.insert("1.0", text)

    def _refresh_list(self, notes):
        """Fill the listbox with notes (pinned first)."""
        self.listbox.delete(0, END)
        for n in notes:
            prefix = "📌 " if n.pinned else ""
            display = f"{prefix}{n.id} | {n.title}  [{n.course or '-'}]"
            self.listbox.insert(END, display)
        self.status.set(f"Loaded {len(notes)} note(s).")

    def _current_selection_id(self):
        """Extract selected note id from listbox line."""
        sel = self.listbox.curselection()
        if not sel:
            return None
        text = self.listbox.get(sel[0])
        # format: "📌 12 | Title [Course]"  or "12 | Title [Course]"
        parts = text.split("|", 1)
        left = parts[0]
        num = ""
        for ch in left:
            if ch.isdigit():
                num += ch
        if not num:
            return None
        return int(num)

    # ----------------- bindings/work -----------------
    def _on_select(self, event):
        """When user selects a note, load fields on the right."""
        note_id = self._current_selection_id()
        if note_id is None:
            return
        # find note by id
        found = None
        for n in self.service.all_notes():
            if n.id == note_id:
                found = n
                break
        if not found:
            return
        self._current_id = found.id
        self.title_var.set(found.title or "")
        self.course_var.set(found.course or "")
        self.tags_var.set(", ".join(found.tags) if found.tags else "")
        self.pin_var.set(1 if found.pinned else 0)
        self.day_var.set(found.day or "")
        self.sstart_var.set(found.session_start or "")
        self.sdur_var.set("" if found.session_duration is None else str(found.session_duration))
        self._set_body(found.body or "")
        self.status.set(f"Selected note #{found.id}")

    def _new_note(self):
        """Clear form to start a new note."""
        self._current_id = None
        self.title_var.set("")
        self.course_var.set("")
        self.tags_var.set("")
        self.pin_var.set(0)
        self.day_var.set("")
        self.sstart_var.set("")
        self.sdur_var.set("")
        self._set_body("")
        self.status.set("New note…")

    def _save_note(self):
        """Create or update note based on current form."""
        title = self.title_var.get().strip()
        body = self._read_body().strip()
        course = self.course_var.get().strip()
        tags_text = self.tags_var.get()

        # new fields
        day = self.day_var.get().strip() or None
        sstart = self.sstart_var.get().strip() or None
        sdur = self.sdur_var.get().strip() or None

        if not title:
            messagebox.showwarning("Missing title", "Please enter a title.")
            return

        if self._current_id is None:
            note = self.service.create_note(title, body, course, tags_text, day, sstart, sdur)
            self._current_id = note.id
            self.status.set(f"Created note #{note.id}")
        else:
            pinned = self.pin_var.get()
            note = self.service.update_note(self._current_id, title, body, course, tags_text, pinned, day, sstart, sdur)
            if note:
                self.status.set(f"Updated note #{note.id}")
            else:
                self.status.set("Update failed (not found).")

        # refresh list view
        self._refresh_list(self.service.all_notes())

    def _delete_note(self):
        """Delete selected note."""
        if self._current_id is None:
            messagebox.showinfo("No selection", "Select a note first.")
            return
        ok = messagebox.askyesno("Delete", "Are you sure you want to delete this note?")
        if not ok:
            return
        self.service.delete_note(self._current_id)
        self._new_note()
        self._refresh_list(self.service.all_notes())
        self.status.set("Note deleted.")

    def _pin_toggle(self):
        """Pin/unpin current note."""
        if self._current_id is None:
            messagebox.showinfo("No selection", "Select a note first.")
            return
        n = self.service.toggle_pin(self._current_id)
        if not n:
            self.status.set("Pin toggle failed.")
            return
        self.pin_var.set(1 if n.pinned else 0)
        self._refresh_list(self.service.all_notes())
        self.status.set(f"{'Pinned' if n.pinned else 'Unpinned'} note #{n.id}")

    def _do_search(self):
        """Run a filter based on keyword/course/tag."""
        res = self.service.search(
            keyword=self.kw_var.get(),
            course=self.scourse_var.get(),
            tag=self.stag_var.get(),
        )
        self._refresh_list(res)
        self.status.set(f"Search results: {len(res)} note(s).")

    def _clear_search(self):
        """Clear search fields and show all notes."""
        self.kw_var.set("")
        self.scourse_var.set("")
        self.stag_var.set("")
        self._refresh_list(self.service.all_notes())
        self.status.set("Search cleared.")

    def _export_csv(self):
        """Export currently shown list to CSV."""
        path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV", "*.csv")],
            title="Export notes to CSV"
        )
        if not path:
            return

        # determine which notes are currently shown
        ids = []
        for i in range(self.listbox.size()):
            line = self.listbox.get(i)
            num = ""
            for ch in line.split("|", 1)[0]:
                if ch.isdigit():
                    num += ch
            if num:
                ids.append(int(num))

        # build list of note objects in that order
        notes = []
        all_map = {n.id: n for n in self.service.all_notes()}
        for nid in ids:
            if nid in all_map:
                notes.append(all_map[nid])

        self.service.export_csv(path, notes)
        self.status.set(f"Exported {len(notes)} note(s) to CSV.")

    def _import_txt(self):
        """Append contents of a .txt file into the Body."""
        path = filedialog.askopenfilename(
            title="Import .txt into body",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        if not path:
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                content = f.read()
            cur = self._read_body()
            combined = (cur + ("\n" if cur else "") + content).strip()
            self._set_body(combined)
            self.status.set("Imported .txt into body.")
        except Exception as e:
            messagebox.showerror("Import error", str(e))


# -------------
# main (R8.1)
# -------------
def main():
    root = Tk()
    root.minsize(900, 600)
    service = NotesService()      # data/persistence
    NotesPanel(root, service)     # GUI
    root.mainloop()               # Event loop (R8)

if __name__ == "__main__":
    main()
